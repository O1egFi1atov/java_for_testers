package foi.sandbox.geometry;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class TriangleTests {

    @Test
    void canCalculatePerimeter() {
        var triangleExample = new Triangle(5.0, 4.0, 3.0);
//        Вариант 1:
//        как один из вариантов реализации проверки: после того, как создан объект типа Triangle (строка выше), вызван
//        конструктор объекта (то, что в скобках у Triangle в строке выше) и в конструкторе объекта указаны его свойства (стороны);
//        можно создать переменную (строка ниже), в которой будет произведен расчет периметра и потом эту переменную внести в проверку.
//        Дополнительно можно добавить printline, чтобы увидеть результат (и добавить итог в ожидаемый результат ниже), но результат можно
//        посмотреть и в режиме отладки (дебаг). Вариант 2 мне нравится больше, он в тесте ниже.
        double resultTrianglePerimeter = triangleExample.perimeter();
//        System.out.println(resultTrianglePerimeter);
        Assertions.assertEquals(12.0, resultTrianglePerimeter);
    }

    @Test
    void canCalculateArea() {
//        Вариант 2:
//        в этом варианте реализации теста мы создаем объект типа Triangle и указываем параметры его свойств непосредственно
//        в параметрах метода .assertEquals, и сразу, тут же из созданного объекта, вызываем
//        метод вычисления площади .area, параметры метода .area уже не указываем, так как этот метод вызывается из объекта
//        и параметры берет из созданного объекта (а именно 5.0, 4.0, 3.0);
//        за счет этого сразу становится понятно какое вычисление производится (не нужно смотреть в строках выше,
//        какого типа объект создан и какие вычисления вложены в переменнуючто, как в Варианте №1);
//        Число строк кода сокращается и его читабельность улучается. (подробнее Урок 1.7. и 1.8. JAVA17)
        Assertions.assertEquals(6.0, new Triangle(5.0, 4.0, 3.0).area());
    }

    @Test
    void triangleSideCannotBeNegative() {
    }
}
